---
// HeroTransition.astro - A component that implements a sophisticated 
// scroll-based animation where a hero SVG transforms into a navbar logo
---
<link rel="stylesheet" href="/src/styles/hero-transition.css">

<div class="hero-transition-container">
  <!-- Fixed header/navbar is now in Header.astro -->

  <!-- Sticky hero section -->
  <section id="hero-section" class="hero-section">
    <div class="hero-content">
      <!-- The hero SVG that will transform into the logo -->
      <svg id="hero-svg" class="hero-svg" viewBox="0 0 200 200" width="200" height="200">
        <!-- Detailed coffee cup with steam -->
        <g fill="currentColor" fill-rule="evenodd">
          <!-- Steam -->
          <path d="M80,40 C85,30 95,35 90,45 C85,55 95,60 100,50 C105,40 115,45 110,55" stroke="currentColor" stroke-width="3" fill="none" />
          <!-- Cup -->
          <path d="M60,70 L140,70 L150,85 L150,150 C150,166.569 136.569,180 120,180 L80,180 C63.431,180 50,166.569 50,150 L50,85 L60,70 Z" />
          <!-- Handle -->
          <path d="M150,100 L170,100 C181.046,100 190,108.954 190,120 C190,131.046 181.046,140 170,140 L150,140 L150,100 Z" />
          <!-- Saucer -->
          <ellipse cx="100" cy="180" rx="60" ry="10" />
        </g>
      </svg>
      <div class="hero-text">
        <h1>Crafting Digital Experiences</h1>
        <p>Building elegant web solutions with code, coffee, and creativity.</p>
        <div class="cta-buttons">
          <button class="primary-btn">View My Work</button>
          <button class="secondary-btn">Get in Touch</button>
        </div>
      </div>
    </div>
  </section>

  <!-- Content section that will trigger the animation -->
  <div id="content-trigger" class="content-section">
    <div class="container">
      <h2>My Portfolio</h2>
      <p>Scroll down to explore my projects and learn more about my approach to web development.</p>
      <!-- Placeholder content -->
      <div class="placeholder-content">
        <div class="card"></div>
        <div class="card"></div>
        <div class="card"></div>
      </div>
    </div>
  </div>
</div>

<script>
  /**
   * HeroTransition Animation Script
   * 
   * This script implements a sophisticated scroll-based animation that 
   * transforms a large SVG in the hero section into a small logo in the navbar.
   * It uses Intersection Observer API for performance and smooth transitions.
   * 
   * Key steps:
   * 1. Observe the content section below the hero with IntersectionObserver.
   * 2. On scroll, get intersectionRatio as animation progress (0 to 1).
   * 3. Interpolate scale, position, and opacity of hero SVG and logo SVG.
   * 4. Use requestAnimationFrame for optimal DOM updates.
   * 
   * Note: The fixed header and logo elements are now in Header.astro,
   * but are accessed here via their IDs for the animation.
   */
  
  document.addEventListener('DOMContentLoaded', () => {
    // Get references to the key elements
    const heroSection = document.getElementById('hero-section');
    const heroSvg = document.getElementById('hero-svg');
    // Access logoSvg and logoContainer which are now in Header.astro
    const logoSvg = document.getElementById('logo-svg');
    const logoContainer = document.getElementById('logo-container');
    const contentTrigger = document.getElementById('content-trigger');
    
    // Ensure all elements are found before proceeding
    if (!heroSection || !heroSvg || !logoSvg || !logoContainer || !contentTrigger) {
        console.error("HeroTransition script: Missing required elements. Header or HeroTransition might not be fully loaded or structured as expected.");
        return; // Exit if elements are not found
    }

    // Set initial state for the animation (overrides default CSS from Header.astro)
    // The hero SVG is visible, the logo SVG is hidden
    heroSvg.style.opacity = '1';
    logoSvg.style.opacity = '0';
    // Also ensure hero SVG is not scaled or translated initially
    heroSvg.style.transform = 'translate(0, 0) scale(1)';


    // Helper: get current positions and scale factor for the animation
    const getPositions = () => {
      // Get the position and dimensions of the hero SVG
      const heroRect = heroSvg.getBoundingClientRect();
      const heroCenter = {
        x: heroRect.left + heroRect.width / 2,
        y: heroRect.top + heroRect.height / 2
      };
      
      // Get the position and dimensions of the logo container in the navbar
      const logoRect = logoContainer.getBoundingClientRect();
      const logoCenter = {
        x: logoRect.left + logoRect.width / 2,
        y: logoRect.top + logoRect.height / 2
      };
      // Calculate scale factor (fit hero SVG into logo container)
      const scaleX = logoRect.width / heroRect.width;
      const scaleY = logoRect.height / heroRect.height;
      const scale = Math.min(scaleX, scaleY);
      
      return { heroCenter, logoCenter, scale, heroRect, logoRect };
    };
    
    // Build thresholds for smooth animation (0, 0.05, ..., 1)
    const thresholds = Array.from({ length: 21 }, (_, i) => i * 0.05);
    
    /**
     * Intersection Observer: observes when the content section enters viewport.
     * The intersectionRatio is used as the animation progress (0 = hero, 1 = logo).
     */
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        // Get the intersection ratio (how much of the target is visible)
        // This will be our animation progress from 0 to 1
        const progress = Math.max(0, Math.min(1, entry.intersectionRatio));
        
        // Use requestAnimationFrame for smooth DOM updates
        window.requestAnimationFrame(() => {
          updateAnimation(progress);
        });
      });
    }, {
      // Observe relative to the viewport
      root: null,
      // Use multiple thresholds for smoother animation
      threshold: thresholds,
      // Start observing slightly before the element enters the viewport
      rootMargin: '0px 0px -10% 0px'
    });
    
    /**
     * updateAnimation(progress)
     * Interpolates transform and opacity for hero SVG and logo SVG.
     * @param {number} progress - Animation progress (0 = hero, 1 = logo)
     */
    function updateAnimation(progress) {
      // Get the current positions for the animation
      const { heroCenter, logoCenter, scale } = getPositions();
      
      // Calculate the interpolated position based on progress
      const currentScale = 1 - (1 - scale) * progress;
      const currentX = heroCenter.x + (logoCenter.x - heroCenter.x) * progress;
      const currentY = heroCenter.y + (logoCenter.y - heroCenter.y) * progress;
      
      // Calculate the translation needed to position the hero SVG
      const translateX = currentX - heroCenter.x;
      const translateY = currentY - heroCenter.y;
      // Animate hero SVG: move, scale, fade out
      heroSvg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
      heroSvg.style.opacity = 1 - progress;
      
      // Fade in the logo SVG as we approach the end of the animation
      logoSvg.style.opacity = progress;
      
      // Optionally, add a class to header when scrolled
      // Access the header element which is now in Header.astro
      const fixedHeader = document.querySelector('.fixed-header');
      if (fixedHeader) {
          if (progress > 0.1) {
            fixedHeader.classList.add('scrolled');
          } else {
            fixedHeader.classList.remove('scrolled');
          }
      }
      
      // Fade out hero text faster than SVG
      const heroText = document.querySelector('.hero-text');
      if (heroText) {
         heroText.style.opacity = 1 - progress * 1.5;
      }
    }
    
    // Start observing the content trigger element
    if (contentTrigger) {
      observer.observe(contentTrigger);
    }
    
    // On resize, recalculate positions and update animation
    window.addEventListener('resize', () => {
      // Check if contentTrigger is still in the DOM
      if (contentTrigger && contentTrigger.getBoundingClientRect) {
         // Recalculate progress based on current scroll position
         const triggerRect = contentTrigger.getBoundingClientRect();
         const viewportHeight = window.innerHeight;
         // Calculate how much of the trigger is above the viewport bottom
         const visibleHeight = Math.max(0, viewportHeight - triggerRect.top);
         const progress = Math.max(0, Math.min(1, visibleHeight / viewportHeight)); // Simple approximation
         
         updateAnimation(progress);
      }
    });
    
    // Initialize animation state on load
    // Check initial scroll position and update animation accordingly
    const initialTriggerRect = contentTrigger.getBoundingClientRect();
    const initialViewportHeight = window.innerHeight;
    const initialVisibleHeight = Math.max(0, initialViewportHeight - initialTriggerRect.top);
    const initialProgress = Math.max(0, Math.min(1, initialVisibleHeight / initialViewportHeight));
    updateAnimation(initialProgress);

  });
</script>
